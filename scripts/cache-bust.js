/**
 * Post-build cache busting
 *
 * Adds content hashes to asset filenames so browsers always load
 * updated files after deployments, even through CDN/browser caches.
 *
 * Runs as the LAST build step (after build-dist.js and Tailwind CSS).
 *
 * Hashed files:
 * - js/events.js   → js/events-{hash}.js   (event data, changes often)
 * - js/app.js      → js/app-{hash}.js      (main script, imports events)
 * - css/style.css  → css/style-{hash}.css   (Tailwind output)
 */

const fs = require('fs');
const path = require('path');
const crypto = require('crypto');

const DIST_DIR = path.join(__dirname, '..', 'dist');

/**
 * Compute 8-char MD5 hash of file contents
 */
function getHash(filePath) {
    return crypto.createHash('md5')
        .update(fs.readFileSync(filePath))
        .digest('hex')
        .slice(0, 8);
}

/**
 * Rename file with content hash: name.ext → name-{hash}.ext
 * Returns new filename (without path) or null if file doesn't exist
 */
function hashFile(filePath) {
    if (!fs.existsSync(filePath)) return null;

    const ext = path.extname(filePath);
    const base = path.basename(filePath, ext);
    const hash = getHash(filePath);
    const newName = `${base}-${hash}${ext}`;

    fs.renameSync(filePath, path.join(path.dirname(filePath), newName));
    return newName;
}

/**
 * Recursively find all HTML files in a directory
 */
function findHtmlFiles(dir) {
    const files = [];
    for (const entry of fs.readdirSync(dir, { withFileTypes: true })) {
        const full = path.join(dir, entry.name);
        if (entry.isDirectory()) files.push(...findHtmlFiles(full));
        else if (entry.name.endsWith('.html')) files.push(full);
    }
    return files;
}

function cacheBust() {
    console.log('\n=== Cache busting ===\n');

    // 1. Hash events.js (leaf dependency — no imports to update)
    const eventsName = hashFile(path.join(DIST_DIR, 'js', 'events.js'));
    if (eventsName) {
        console.log(`  ✓ js/events.js → js/${eventsName}`);
    }

    // 2. Update events import in app.js, then hash app.js
    //    app.js content changes because the import path changed,
    //    so it gets a new hash too — cascading cache invalidation.
    const appPath = path.join(DIST_DIR, 'js', 'app.js');
    if (eventsName && fs.existsSync(appPath)) {
        let content = fs.readFileSync(appPath, 'utf8');
        content = content.replace(
            /from\s+['"]\.\/events\.js['"]/,
            `from './${eventsName}'`
        );
        fs.writeFileSync(appPath, content, 'utf8');
    }
    const appName = hashFile(appPath);
    if (appName) {
        console.log(`  ✓ js/app.js → js/${appName}`);
    }

    // 3. Hash style.css (generated by Tailwind in previous build step)
    const styleName = hashFile(path.join(DIST_DIR, 'css', 'style.css'));
    if (styleName) {
        console.log(`  ✓ css/style.css → css/${styleName}`);
    }

    // 4. Update all HTML files in dist/
    //    Using path-prefixed replacements (e.g. "js/events.js") to avoid
    //    false matches like "fbevents.js" in third-party scripts.
    const htmlFiles = findHtmlFiles(DIST_DIR);
    console.log(`\n  Updating ${htmlFiles.length} HTML files...`);

    let updated = 0;
    for (const file of htmlFiles) {
        let html = fs.readFileSync(file, 'utf8');
        const original = html;

        if (eventsName) {
            html = html.replaceAll('js/events.js', `js/${eventsName}`);
        }
        if (appName) {
            html = html.replaceAll('js/app.js', `js/${appName}`);
        }
        if (styleName) {
            html = html.replaceAll('css/style.css', `css/${styleName}`);
        }

        if (html !== original) {
            fs.writeFileSync(file, html, 'utf8');
            console.log(`    ✓ ${path.relative(DIST_DIR, file)}`);
            updated++;
        }
    }

    console.log(`\n  ${updated} file(s) updated`);
    console.log('\n=== Cache busting complete ===');
}

cacheBust();
