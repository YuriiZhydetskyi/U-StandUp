/**
 * Full build script that creates a complete dist/ folder for deployment
 *
 * Usage: npm run build
 *
 * This script:
 * 1. Cleans dist/ folder
 * 2. Copies static files (html, css, js, etc.)
 * 3. Parses HTML for image dimensions
 * 4. Generates responsive images (1x, 2x) based on display size
 * 5. Transforms HTML with srcset attributes
 * 6. Builds events from YAML ‚Üí events.js + events.json
 * 7. Generates event detail pages
 * 8. Generates sitemap.xml
 */

const fs = require('fs');
const path = require('path');
const yaml = require('js-yaml');
const sharp = require('sharp');
const { parse } = require('node-html-parser');

const ROOT_DIR = path.join(__dirname, '..');
const SRC_DIR = path.join(ROOT_DIR, 'src');
const DIST_DIR = path.join(ROOT_DIR, 'dist');
const EVENTS_SOURCE = path.join(SRC_DIR, 'events');

// Load shared constants
const constants = require('../src/data/constants.json');
const SITE_URL = constants.SITE_URL;
const categoryLabels = constants.CATEGORY_LABELS;
const MONTHS_FULL = constants.MONTHS_FULL;

// Static files and folders to copy
const STATIC_FILES = [
    'index.html',
    'all-events.html',
    'other-clubs.html',
    'robots.txt',
    'llms.txt',
    'CNAME',
    'ics-browserified.js'
];

// Files to copy to root (for Google favicon discovery)
const ROOT_COPY_FILES = [
    { src: 'img/favicon.ico', dest: 'favicon.ico' }
];

const STATIC_FOLDERS = [
    'js',
    'data',
    'ThankYouPage'
];

// Note: CSS is generated by Tailwind CLI after this script runs

// Image optimization settings
const WEBP_QUALITY = 80;
const EXTENSIONS_TO_CONVERT = ['.jpg', '.jpeg', '.png', '.webp', '.gif'];
const EXTENSIONS_TO_COPY = ['.svg', '.ico'];
// Files to copy as-is without WebP conversion (favicons must stay as PNG for browser compatibility)
const FILES_TO_COPY_AS_IS = ['favicon-', 'apple-touch-icon'];

// Store image dimensions found in HTML
// Map: imagePath -> { width, height }
let imageDimensionsMap = new Map();

// Store generated image sizes for srcset
// Map: imagePath -> number[] (array of widths)
let generatedSizesMap = new Map();

// Target sizes for responsive images (will filter by original size)
// Includes smaller sizes for mobile 1x DPR devices
const RESPONSIVE_SIZES = [300, 400, 600, 800, 1000, 1200];
// For small images like logos, use smaller steps
const SMALL_IMAGE_SIZES = [80, 120, 160, 240];

/**
 * Recursively copy a directory
 */
function copyDir(src, dest) {
    if (!fs.existsSync(dest)) {
        fs.mkdirSync(dest, { recursive: true });
    }

    const entries = fs.readdirSync(src, { withFileTypes: true });

    for (const entry of entries) {
        const srcPath = path.join(src, entry.name);
        const destPath = path.join(dest, entry.name);

        if (entry.isDirectory()) {
            copyDir(srcPath, destPath);
        } else {
            fs.copyFileSync(srcPath, destPath);
        }
    }
}

/**
 * Find all files with given extensions recursively
 */
function findFiles(dir, extensions, files = []) {
    const entries = fs.readdirSync(dir, { withFileTypes: true });

    for (const entry of entries) {
        const fullPath = path.join(dir, entry.name);
        if (entry.isDirectory()) {
            findFiles(fullPath, extensions, files);
        } else if (extensions.some(ext => entry.name.endsWith(ext))) {
            files.push(fullPath);
        }
    }

    return files;
}

/**
 * Parse HTML and JS files to extract image dimensions
 */
async function parseHtmlForImageDimensions() {
    console.log('Parsing HTML and JS for image dimensions...');

    imageDimensionsMap = new Map();

    // Parse HTML files
    const htmlFiles = findFiles(SRC_DIR, ['.html']);
    for (const htmlFile of htmlFiles) {
        const content = fs.readFileSync(htmlFile, 'utf8');
        const root = parse(content);
        const imgs = root.querySelectorAll('img');

        for (const img of imgs) {
            const src = img.getAttribute('src');
            const width = img.getAttribute('width');
            const height = img.getAttribute('height');

            if (!src) continue;

            // Skip external URLs and data URIs
            if (src.startsWith('http://') || src.startsWith('https://') || src.startsWith('data:')) {
                continue;
            }

            // Skip SVGs
            if (src.endsWith('.svg')) continue;

            // Normalize path (remove leading /)
            const normalizedSrc = src.startsWith('/') ? src.slice(1) : src;

            if (width && height) {
                const w = parseInt(width, 10);
                const h = parseInt(height, 10);

                if (!isNaN(w) && !isNaN(h)) {
                    // If image already in map, keep the largest dimensions
                    const existing = imageDimensionsMap.get(normalizedSrc);
                    if (!existing || existing.width < w) {
                        imageDimensionsMap.set(normalizedSrc, { width: w, height: h });
                    }
                }
            }
        }
    }

    // Parse JS files for img tags with dimensions
    const jsFiles = findFiles(SRC_DIR, ['.js']);
    const imgRegex = /<img[^>]*src=["']([^"']+)["'][^>]*width=["'](\d+)["'][^>]*height=["'](\d+)["'][^>]*>|<img[^>]*width=["'](\d+)["'][^>]*height=["'](\d+)["'][^>]*src=["']([^"']+)["'][^>]*>/g;

    for (const jsFile of jsFiles) {
        const content = fs.readFileSync(jsFile, 'utf8');
        let match;

        while ((match = imgRegex.exec(content)) !== null) {
            // Handle both orders of attributes
            const src = match[1] || match[6];
            const width = parseInt(match[2] || match[4], 10);
            const height = parseInt(match[3] || match[5], 10);

            if (!src || src.endsWith('.svg')) continue;
            if (src.startsWith('http://') || src.startsWith('https://')) continue;

            const normalizedSrc = src.startsWith('/') ? src.slice(1) : src;

            if (!isNaN(width) && !isNaN(height)) {
                const existing = imageDimensionsMap.get(normalizedSrc);
                if (!existing || existing.width < width) {
                    imageDimensionsMap.set(normalizedSrc, { width, height });
                }
            }
        }
    }

    // Parse YAML event files for image paths
    // Event images are displayed at 400px in hero section
    await parseEventImagesFromYaml();

    // Parse club logos from other-clubs.html JS data
    // Club logos are displayed at 80x80
    parseClubLogosFromHtml();

    // Add known dimensions for images used via JS variables
    // Logo in header.js: width="120" height="50"
    imageDimensionsMap.set('img/logo.webp', { width: 120, height: 50 });

    console.log(`  Found ${imageDimensionsMap.size} images with dimensions\n`);
    return imageDimensionsMap;
}

/**
 * Parse YAML event files to extract image paths
 * Hero section CSS: 400px on desktop, max 450px on mobile
 * We use 400px as base (generates 400w + 800w for retina)
 */
async function parseEventImagesFromYaml() {
    const eventFiles = fs.readdirSync(EVENTS_SOURCE)
        .filter(f => f.endsWith('.yaml') || f.endsWith('.yml'));

    for (const file of eventFiles) {
        const filePath = path.join(EVENTS_SOURCE, file);
        const content = fs.readFileSync(filePath, 'utf8');

        try {
            const event = yaml.load(content);
            if (event.image) {
                // Normalize path: add img/ prefix if missing, remove leading /
                let imagePath = event.image;
                if (imagePath.startsWith('/')) {
                    imagePath = imagePath.slice(1);
                }
                if (!imagePath.startsWith('img/')) {
                    imagePath = `img/${imagePath}`;
                }

                // Check if file exists
                const fullPath = path.join(SRC_DIR, imagePath);
                if (fs.existsSync(fullPath)) {
                    // Read actual image dimensions to calculate correct aspect ratio
                    const metadata = await sharp(fullPath).metadata();
                    const aspectRatio = metadata.width / metadata.height;
                    const targetWidth = 400;
                    const targetHeight = Math.round(targetWidth / aspectRatio);

                    const existing = imageDimensionsMap.get(imagePath);
                    if (!existing || existing.width < targetWidth) {
                        imageDimensionsMap.set(imagePath, { width: targetWidth, height: targetHeight });
                    }
                }
            }
        } catch (err) {
            // Skip invalid YAML
        }
    }
}

/**
 * Parse club logos from other-clubs.html JavaScript data
 * Club logos are displayed at 80x80
 */
function parseClubLogosFromHtml() {
    const clubsHtmlPath = path.join(SRC_DIR, 'other-clubs.html');
    if (!fs.existsSync(clubsHtmlPath)) return;

    const content = fs.readFileSync(clubsHtmlPath, 'utf8');

    // Extract picture paths from the clubs array in JS
    // Matches: picture: "img/something.webp"
    const pictureRegex = /picture:\s*["']([^"']+)["']/g;
    let match;

    while ((match = pictureRegex.exec(content)) !== null) {
        let imagePath = match[1];

        // Normalize path
        if (imagePath.startsWith('/')) {
            imagePath = imagePath.slice(1);
        }

        // Skip non-image files
        if (!imagePath.match(/\.(webp|jpg|jpeg|png)$/i)) continue;

        // Check if file exists
        const fullPath = path.join(SRC_DIR, imagePath);
        if (fs.existsSync(fullPath)) {
            // Club logos are 80x80
            imageDimensionsMap.set(imagePath, { width: 80, height: 80 });
        }
    }
}

/**
 * Check if any output file is older than the source file
 */
function needsRegeneration(srcPath, destPaths) {
    const srcStat = fs.statSync(srcPath);
    for (const destPath of destPaths) {
        if (!fs.existsSync(destPath)) return true;
        const destStat = fs.statSync(destPath);
        if (destStat.mtime < srcStat.mtime) return true;
    }
    return false;
}

/**
 * Generate responsive images with multiple sizes
 * Dynamically generates sizes based on original image dimensions
 * Uses mtime-based caching to skip unchanged images
 */
async function generateResponsiveImages() {
    console.log('Generating responsive images...');

    const srcImgDir = path.join(SRC_DIR, 'img');
    const destImgDir = path.join(DIST_DIR, 'img');

    if (!fs.existsSync(srcImgDir)) {
        console.log('  No img/ folder found\n');
        return;
    }

    fs.mkdirSync(destImgDir, { recursive: true });

    const files = fs.readdirSync(srcImgDir);
    let generated = 0;
    let skipped = 0;
    let copied = 0;
    let warnings = 0;
    let totalSaved = 0;

    for (const file of files) {
        const ext = path.extname(file).toLowerCase();
        const srcPath = path.join(srcImgDir, file);
        const stat = fs.statSync(srcPath);

        if (stat.isDirectory()) {
            // Recursively copy subdirectories
            copyDir(srcPath, path.join(destImgDir, file));
            console.log(`  ‚úì ${file}/ (copied)`);
            continue;
        }

        // For images that can be resized
        if (EXTENSIONS_TO_CONVERT.includes(ext)) {
            // Check if this file should be copied as-is (favicons, apple-touch-icon)
            const shouldCopyAsIs = FILES_TO_COPY_AS_IS.some(prefix => file.startsWith(prefix));
            if (shouldCopyAsIs) {
                const destPath = path.join(destImgDir, file);
                if (!needsRegeneration(srcPath, [destPath])) {
                    console.log(`  ‚è≠Ô∏è  ${file} (up to date)`);
                    skipped++;
                    continue;
                }
                fs.copyFileSync(srcPath, destPath);
                console.log(`  ‚úì ${file} (copied as-is for favicon)`);
                copied++;
                continue;
            }

            const imagePath = `img/${file}`;
            const dimensions = imageDimensionsMap.get(imagePath);
            const nameWithoutExt = path.basename(file, ext);
            const inputSize = stat.size;

            // Get original image dimensions
            const metadata = await sharp(srcPath).metadata();
            const originalWidth = metadata.width;
            const originalHeight = metadata.height;
            const aspectRatio = originalWidth / originalHeight;

            if (dimensions) {
                const baseWidth = dimensions.width;

                // Determine which size set to use based on base width
                const targetSizes = baseWidth <= 160 ? SMALL_IMAGE_SIZES : RESPONSIVE_SIZES;

                // Filter sizes: include all sizes up to original width
                // This provides smaller sizes for 1x DPR mobile devices
                const sizesToGenerate = targetSizes.filter(
                    size => size <= originalWidth
                );

                // Always include base size if not in list
                if (!sizesToGenerate.includes(baseWidth) && baseWidth <= originalWidth) {
                    sizesToGenerate.push(baseWidth);
                }

                // Sort sizes
                sizesToGenerate.sort((a, b) => a - b);

                // Store generated sizes for srcset building (needed even if skipped)
                generatedSizesMap.set(imagePath, sizesToGenerate);

                // Check if all output files exist and are newer than source
                const outputPaths = sizesToGenerate.map(w =>
                    path.join(destImgDir, `${nameWithoutExt}-${w}.webp`)
                );

                if (!needsRegeneration(srcPath, outputPaths)) {
                    console.log(`  ‚è≠Ô∏è  ${file} (up to date)`);
                    skipped++;
                    continue;
                }

                // Generate all sizes
                let totalOutputSize = 0;
                const generatedFiles = [];

                const isAnimated = ext === '.gif';

                for (const width of sizesToGenerate) {
                    const height = Math.round(width / aspectRatio);
                    const destPath = path.join(destImgDir, `${nameWithoutExt}-${width}.webp`);

                    await sharp(srcPath, { animated: isAnimated })
                        .resize(width, height, { fit: 'cover' })
                        .webp({ quality: WEBP_QUALITY })
                        .toFile(destPath);

                    totalOutputSize += fs.statSync(destPath).size;
                    generatedFiles.push(`${nameWithoutExt}-${width}.webp`);
                }

                // Calculate savings: compare smallest generated vs original
                const smallestSize = fs.statSync(
                    path.join(destImgDir, `${nameWithoutExt}-${sizesToGenerate[0]}.webp`)
                ).size;
                const savings = ((1 - smallestSize / inputSize) * 100).toFixed(0);
                totalSaved += inputSize - smallestSize;

                const sizesStr = sizesToGenerate.join('w, ') + 'w';
                console.log(`  ‚úì ${file} ‚Üí [${sizesStr}] (${savings}% saved for 1x)`);

                generated++;
            } else {
                // No dimensions found, copy as-is with WebP conversion
                const destPath = path.join(destImgDir, `${nameWithoutExt}.webp`);

                if (!needsRegeneration(srcPath, [destPath])) {
                    console.log(`  ‚è≠Ô∏è  ${file} (up to date, no dimensions)`);
                    skipped++;
                    continue;
                }

                const isAnimatedFallback = ext === '.gif';
                await sharp(srcPath, { animated: isAnimatedFallback })
                    .webp({ quality: WEBP_QUALITY })
                    .toFile(destPath);

                const outputSize = fs.statSync(destPath).size;
                totalSaved += inputSize - outputSize;

                console.log(`  ‚ö† ${file} ‚Üí ${nameWithoutExt}.webp (no dimensions in HTML, copying as-is)`);
                warnings++;
            }
        } else if (EXTENSIONS_TO_COPY.includes(ext)) {
            // Copy SVG, GIF, ICO as-is
            const destPath = path.join(destImgDir, file);
            if (!needsRegeneration(srcPath, [destPath])) {
                console.log(`  ‚è≠Ô∏è  ${file} (up to date)`);
                skipped++;
                continue;
            }
            fs.copyFileSync(srcPath, destPath);
            console.log(`  ‚úì ${file}`);
            copied++;
        }
    }

    console.log(`\n  Generated: ${generated}, Skipped: ${skipped}, Copied: ${copied}, Warnings: ${warnings}`);
    if (totalSaved > 0) {
        console.log(`  Total saved: ${(totalSaved / 1024).toFixed(0)}KB\n`);
    } else {
        console.log('');
    }

    // Clean up stale files in dist/img/ that were previously copied
    // but should now be converted to WebP (e.g. .gif after adding GIF support)
    const distFiles = fs.readdirSync(destImgDir);
    let removed = 0;
    const convertableNonWebp = EXTENSIONS_TO_CONVERT.filter(e => e !== '.webp');
    for (const distFile of distFiles) {
        const distPath = path.join(destImgDir, distFile);
        if (fs.statSync(distPath).isDirectory()) continue;

        const ext = path.extname(distFile).toLowerCase();
        if (convertableNonWebp.includes(ext)) {
            // This file should have been converted to .webp, not copied ‚Äî it's a leftover
            const shouldCopyAsIs = FILES_TO_COPY_AS_IS.some(prefix => distFile.startsWith(prefix));
            if (!shouldCopyAsIs) {
                fs.unlinkSync(distPath);
                console.log(`  üóëÔ∏è  Removed stale: ${distFile}`);
                removed++;
            }
        }
    }
    if (removed > 0) {
        console.log(`  Removed ${removed} stale file(s) from dist/img/\n`);
    }
}

/**
 * Get responsive image filename based on dimensions
 */
function getResponsiveImageSrc(originalSrc) {
    // Normalize path
    const normalizedSrc = originalSrc.startsWith('/') ? originalSrc.slice(1) : originalSrc;
    const dimensions = imageDimensionsMap.get(normalizedSrc);

    if (!dimensions) {
        // No dimensions, use original path but with .webp extension
        const ext = path.extname(normalizedSrc);
        if (['.jpg', '.jpeg', '.png', '.webp', '.gif'].includes(ext.toLowerCase())) {
            return originalSrc.replace(ext, '.webp');
        }
        return originalSrc;
    }

    const ext = path.extname(normalizedSrc);
    const nameWithoutExt = normalizedSrc.replace(ext, '');
    const leading = originalSrc.startsWith('/') ? '/' : '';

    return `${leading}${nameWithoutExt}-${dimensions.width}.webp`;
}

/**
 * Get srcset attribute for an image
 */
function getSrcsetAttribute(originalSrc) {
    const normalizedSrc = originalSrc.startsWith('/') ? originalSrc.slice(1) : originalSrc;
    const dimensions = imageDimensionsMap.get(normalizedSrc);

    if (!dimensions) return null;

    const ext = path.extname(normalizedSrc);
    const nameWithoutExt = normalizedSrc.replace(ext, '');
    const leading = originalSrc.startsWith('/') ? '/' : '';

    const src1x = `${leading}${nameWithoutExt}-${dimensions.width}.webp`;
    const src2x = `${leading}${nameWithoutExt}-${dimensions.width * 2}.webp`;

    // Check if 2x version exists
    const dest2x = path.join(DIST_DIR, nameWithoutExt.replace(/^\//, '') + `-${dimensions.width * 2}.webp`);
    if (fs.existsSync(dest2x)) {
        return `${src1x} 1x, ${src2x} 2x`;
    }

    return `${src1x} 1x`;
}

/**
 * Transform HTML content with responsive image srcset
 */
function transformHtmlWithSrcset(htmlContent) {
    const root = parse(htmlContent, { comment: true });
    const imgs = root.querySelectorAll('img');

    for (const img of imgs) {
        const src = img.getAttribute('src');
        if (!src) continue;

        // Skip external URLs, data URIs, and SVGs
        if (src.startsWith('http://') || src.startsWith('https://') ||
            src.startsWith('data:') || src.endsWith('.svg')) {
            continue;
        }

        const newSrc = getResponsiveImageSrc(src);
        const srcset = getSrcsetAttribute(src);

        img.setAttribute('src', newSrc);
        if (srcset) {
            img.setAttribute('srcset', srcset);
        }
    }

    return root.toString();
}

/**
 * Clean and create dist directory
 * Preserves img/ folder for incremental image builds
 */
function cleanDist() {
    console.log('Cleaning dist/...');
    if (fs.existsSync(DIST_DIR)) {
        // Preserve img/ folder for caching, delete everything else
        const entries = fs.readdirSync(DIST_DIR);
        for (const entry of entries) {
            const entryPath = path.join(DIST_DIR, entry);
            if (entry === 'img') {
                console.log('  ‚è≠Ô∏è  Preserving img/ for caching');
                continue;
            }
            fs.rmSync(entryPath, { recursive: true });
        }
    } else {
        fs.mkdirSync(DIST_DIR, { recursive: true });
    }
    console.log('‚úì dist/ cleaned (img/ preserved)\n');
}

/**
 * Copy static files to dist (with HTML transformation)
 */
function copyStaticFiles() {
    console.log('Copying static files from src/...');

    // Copy individual files from src/
    for (const file of STATIC_FILES) {
        const src = path.join(SRC_DIR, file);
        const dest = path.join(DIST_DIR, file);
        if (fs.existsSync(src)) {
            if (file.endsWith('.html')) {
                // Transform HTML with srcset
                const content = fs.readFileSync(src, 'utf8');
                const transformed = transformHtmlWithSrcset(content);
                fs.writeFileSync(dest, transformed, 'utf8');
                console.log(`  ‚úì ${file} (transformed)`);
            } else {
                fs.copyFileSync(src, dest);
                console.log(`  ‚úì ${file}`);
            }
        }
    }

    // Copy folders from src/
    for (const folder of STATIC_FOLDERS) {
        const src = path.join(SRC_DIR, folder);
        const dest = path.join(DIST_DIR, folder);
        if (fs.existsSync(src)) {
            copyDirWithHtmlTransform(src, dest);
            console.log(`  ‚úì ${folder}/`);
        }
    }

    // Create css folder for Tailwind output
    const cssDir = path.join(DIST_DIR, 'css');
    if (!fs.existsSync(cssDir)) {
        fs.mkdirSync(cssDir, { recursive: true });
        console.log('  ‚úì css/ (created for Tailwind)');
    }

    // Copy files to root (favicon.ico for Google)
    for (const { src, dest } of ROOT_COPY_FILES) {
        const srcPath = path.join(SRC_DIR, src);
        const destPath = path.join(DIST_DIR, dest);
        if (fs.existsSync(srcPath)) {
            fs.copyFileSync(srcPath, destPath);
            console.log(`  ‚úì ${dest} (copied to root for Google)`);
        }
    }

    console.log('');
}

/**
 * Copy directory with HTML transformation
 */
function copyDirWithHtmlTransform(src, dest) {
    if (!fs.existsSync(dest)) {
        fs.mkdirSync(dest, { recursive: true });
    }

    const entries = fs.readdirSync(src, { withFileTypes: true });

    for (const entry of entries) {
        const srcPath = path.join(src, entry.name);
        const destPath = path.join(dest, entry.name);

        if (entry.isDirectory()) {
            copyDirWithHtmlTransform(srcPath, destPath);
        } else if (entry.name.endsWith('.html')) {
            const content = fs.readFileSync(srcPath, 'utf8');
            const transformed = transformHtmlWithSrcset(content);
            fs.writeFileSync(destPath, transformed, 'utf8');
        } else {
            fs.copyFileSync(srcPath, destPath);
        }
    }
}

/**
 * Build events from YAML files
 */
function buildEvents() {
    console.log('Building events from YAML...');

    const files = fs.readdirSync(EVENTS_SOURCE)
        .filter(f => f.endsWith('.yaml') || f.endsWith('.yml'))
        .sort()
        .reverse();

    const events = [];

    for (const file of files) {
        const filePath = path.join(EVENTS_SOURCE, file);
        const content = fs.readFileSync(filePath, 'utf8');

        try {
            const event = yaml.load(content);
            if (event.description) {
                event.description = event.description.trim();
            }
            if (event.ticketLink && !event.googleFormLink) {
                event.googleFormLink = event.ticketLink;
            }
            events.push(event);
            console.log(`  ‚úì ${file}`);
        } catch (err) {
            console.error(`  ‚úó ${file}: ${err.message}`);
        }
    }

    // Sort events
    events.sort((a, b) => {
        if (a.isFavorite && !b.isFavorite) return -1;
        if (!a.isFavorite && b.isFavorite) return 1;
        return new Date(b.date) - new Date(a.date);
    });

    // Write events.js
    const jsContent = `// Auto-generated from YAML files
// Run 'npm run build:dist' to regenerate

const events = ${JSON.stringify(events, null, 2)};

export default events;
`;
    const jsPath = path.join(DIST_DIR, 'js', 'events.js');
    fs.writeFileSync(jsPath, jsContent, 'utf8');
    console.log(`\n  ‚úì js/events.js`);

    // Write events.json
    const jsonPath = path.join(DIST_DIR, 'data', 'events.json');
    fs.writeFileSync(jsonPath, JSON.stringify(events, null, 2), 'utf8');
    console.log(`  ‚úì data/events.json`);

    console.log(`\nTotal: ${events.length} events\n`);
    return events;
}

/**
 * Format date helpers
 */
function formatDate(dateString) {
    const date = new Date(dateString);
    return `${date.getDate()} ${MONTHS_FULL[date.getMonth()]} ${date.getFullYear()}`;
}

function formatDateISO(dateString, time) {
    return `${dateString}T${time}:00`;
}

function stripHtml(html) {
    return (html || '').replace(/<[^>]*>/g, '').replace(/\n/g, ' ').trim().substring(0, 200);
}

/**
 * Get day of week in Ukrainian
 */
function getDayOfWeek(dateString) {
    const days = ['–ù–µ–¥—ñ–ª—è', '–ü–æ–Ω–µ–¥—ñ–ª–æ–∫', '–í—ñ–≤—Ç–æ—Ä–æ–∫', '–°–µ—Ä–µ–¥–∞', '–ß–µ—Ç–≤–µ—Ä', "–ü'—è—Ç–Ω–∏—Ü—è", '–°—É–±–æ—Ç–∞'];
    const date = new Date(dateString);
    return days[date.getDay()];
}

/**
 * Get responsive image attributes for event images
 * Returns src, srcset with w descriptors, and sizes for hero section
 * Uses generatedSizesMap to include all available sizes in srcset
 */
function getEventImageAttributes(imagePath, options = {}) {
    if (!imagePath) return { src: '', srcset: '', sizes: '' };

    const normalizedPath = imagePath.startsWith('/') ? imagePath.slice(1) : imagePath;
    const dimensions = imageDimensionsMap.get(normalizedPath);
    const generatedSizes = generatedSizesMap.get(normalizedPath);

    if (!dimensions) {
        // No dimensions, just convert extension to webp
        const ext = path.extname(normalizedPath);
        const webpPath = normalizedPath.replace(ext, '.webp');
        return {
            src: `/${webpPath}`,
            srcset: '',
            sizes: ''
        };
    }

    const ext = path.extname(normalizedPath);
    const nameWithoutExt = normalizedPath.replace(ext, '');
    const baseWidth = dimensions.width;

    // Default src is the base size
    const src = `/${nameWithoutExt}-${baseWidth}.webp`;

    // Build srcset from all generated sizes
    let srcset = '';
    if (generatedSizes && generatedSizes.length > 0) {
        srcset = generatedSizes
            .map(w => `/${nameWithoutExt}-${w}.webp ${w}w`)
            .join(', ');
    } else {
        // Fallback to just base size
        srcset = `${src} ${baseWidth}w`;
    }

    // Hero section sizes: 400px on desktop (>=768px), max 450px on mobile
    const sizes = options.isHero
        ? '(min-width: 768px) 400px, min(450px, 100vw)'
        : '';

    return { src, srcset, sizes };
}

/**
 * Render header HTML for pre-rendering
 * Must match header.js renderHeader() function
 */
function renderHeaderHtml(activePage = 'home') {
    const nav = [
        { id: 'home', label: '–ì–æ–ª–æ–≤–Ω–∞', href: '/' },
        { id: 'all-events', label: '–í—Å—ñ –ø–æ–¥—ñ—ó', href: '/all-events.html' },
        { id: 'about', label: '–ü—Ä–æ –Ω–∞—Å', href: '/#about-us' },
        { id: 'clubs', label: '–Ü–Ω—à—ñ –∫–ª—É–±–∏', href: '/other-clubs.html' }
    ];

    const logoAttrs = getEventImageAttributes('img/logo.webp');
    const logoSrcset = logoAttrs.srcset ? ` srcset="${logoAttrs.srcset}"` : '';

    const navItems = nav.map(item => `
                        <li class="nav-item">
                            <a class="nav-link ${activePage === item.id ? 'active' : ''}" href="${item.href}">${item.label}</a>
                        </li>`).join('');

    return `<header>
        <nav class="navbar">
            <div class="container">
                <a class="navbar-brand" href="index.html">
                    <img src="${logoAttrs.src}"${logoSrcset} sizes="120px" alt="–£ –°—Ç–µ–Ω–¥–∞–ø" width="120" height="50">
                    <span class="brand-tagline">—É–∫—Ä–∞—ó–Ω—Å—å–∫–∏–π —Å—Ç–µ–Ω–¥–∞–ø —É –ö–µ–ª—å–Ω—ñ</span>
                </a>
                <button class="navbar-toggler" type="button" aria-label="Toggle navigation" onclick="toggleMenu()">
                    <span></span>
                    <span></span>
                    <span></span>
                </button>
                <div class="navbar-collapse" id="navbarNav">
                    <ul class="navbar-nav">${navItems}
                    </ul>
                </div>
            </div>
        </nav>
    </header>`;
}

/**
 * Pre-render header in HTML files
 */
function preRenderHeader() {
    console.log('Pre-rendering headers...');

    const pages = [
        { file: 'index.html', activePage: 'home' },
        { file: 'all-events.html', activePage: 'all-events' },
        { file: 'other-clubs.html', activePage: 'clubs' }
    ];

    for (const page of pages) {
        const filePath = path.join(DIST_DIR, page.file);
        if (!fs.existsSync(filePath)) continue;

        let html = fs.readFileSync(filePath, 'utf8');

        // Replace the comment placeholder with actual header
        const headerHtml = renderHeaderHtml(page.activePage);
        html = html.replace('<!-- Header is injected by JS -->', headerHtml);
        html = html.replace('<!-- Header injected by JS -->', headerHtml);

        fs.writeFileSync(filePath, html, 'utf8');
        console.log(`  ‚úì ${page.file}`);
    }

    console.log('');
}

/**
 * Pre-render hero section in index.html with the featured event
 */
function preRenderHeroSection(events) {
    console.log('Pre-rendering hero section...');

    const now = new Date();

    // Get upcoming events (same logic as app.js)
    const upcomingEvents = events
        .filter(e => new Date(`${e.date}T${e.time}`) >= now)
        .sort((a, b) => new Date(a.date) - new Date(b.date));

    if (upcomingEvents.length === 0) {
        console.log('  No upcoming events, skipping hero pre-render\n');
        return;
    }

    // Find hero event (same logic as app.js displayHeroEvent)
    const heroEvent = upcomingEvents.find(e => e.isFavorite && e.image)
        || upcomingEvents.find(e => e.image)
        || upcomingEvents[0];

    if (!heroEvent || !heroEvent.image) {
        console.log('  No hero event with image found, skipping\n');
        return;
    }

    const imageAttrs = getEventImageAttributes(heroEvent.image, { isHero: true });

    // Get actual dimensions from map for correct aspect ratio
    let imagePath = heroEvent.image;
    if (imagePath.startsWith('/')) imagePath = imagePath.slice(1);
    if (!imagePath.startsWith('img/')) imagePath = `img/${imagePath}`;
    const dimensions = imageDimensionsMap.get(imagePath) || { width: 400, height: 500 };

    const categoryLabel = categoryLabels[heroEvent.category] || '–ü–æ–¥—ñ—è';
    const dateFormatted = `${getDayOfWeek(heroEvent.date)}, ${formatDate(heroEvent.date)}`;
    const description = stripHtml(heroEvent.description || '').substring(0, 200) + '...';

    // Build actions HTML
    let actionsHtml = '';
    if (heroEvent.ticketLink || heroEvent.googleFormLink) {
        actionsHtml += `<a href="${heroEvent.ticketLink || heroEvent.googleFormLink}" target="_blank" class="btn btn-primary">–ü—Ä–∏–¥–±–∞—Ç–∏ –∫–≤–∏—Ç–∫–∏</a>`;
    }
    actionsHtml += `<a href="/events/${heroEvent.id}/" class="btn btn-outline-light">–î—ñ–∑–Ω–∞—Ç–∏—Å—è –±—ñ–ª—å—à–µ</a>`;

    // Location HTML
    let locationHtml = heroEvent.location;
    if (heroEvent.linkToMaps) {
        locationHtml = `<a href="${heroEvent.linkToMaps}" target="_blank" rel="noopener" style="color: white;">${heroEvent.location}</a>`;
    }

    // Read index.html from dist
    const indexPath = path.join(DIST_DIR, 'index.html');
    let html = fs.readFileSync(indexPath, 'utf8');

    // Add preload link for hero image with srcset support (before </head>)
    const preloadSrcset = imageAttrs.srcset ? ` imagesrcset="${imageAttrs.srcset}" imagesizes="${imageAttrs.sizes}"` : '';
    const preloadLink = `<link rel="preload" href="${imageAttrs.src}" as="image"${preloadSrcset} fetchpriority="high">\n</head>`;
    html = html.replace('</head>', preloadLink);

    // Build srcset and sizes attributes
    const srcsetAttr = imageAttrs.srcset ? ` srcset="${imageAttrs.srcset}"` : '';
    const sizesAttr = imageAttrs.sizes ? ` sizes="${imageAttrs.sizes}"` : '';

    // Replace hero section (remove display:none and populate content)
    const heroSectionRegex = /<section class="hero-event" id="hero-event" style="display: none;">[\s\S]*?<\/section>\s*<!-- Filter/;

    const preRenderedHero = `<section class="hero-event" id="hero-event">
            <div class="container">
                <div class="hero-event__inner">
                    <a href="/events/${heroEvent.id}/" id="hero-event-link" class="hero-event__image">
                        <img id="hero-event-image" src="${imageAttrs.src}"${srcsetAttr}${sizesAttr} alt="${heroEvent.name}" fetchpriority="high" width="${dimensions.width}" height="${dimensions.height}">
                    </a>
                    <div class="hero-event__content">
                        <span class="hero-event__badge" id="hero-event-badge">${categoryLabel}</span>
                        <h1 class="hero-event__title" id="hero-event-title">${heroEvent.name}</h1>
                        <div class="hero-event__meta">
                            <div class="hero-event__meta-item">
                                <span>üìÖ</span>
                                <span id="hero-event-date">${dateFormatted}</span>
                            </div>
                            <div class="hero-event__meta-item">
                                <span>üïê</span>
                                <span id="hero-event-time">${heroEvent.time}</span>
                            </div>
                            <div class="hero-event__meta-item">
                                <span>üìç</span>
                                <span id="hero-event-location">${locationHtml}</span>
                            </div>
                        </div>
                        <div class="hero-event__description" id="hero-event-description">${description}</div>
                        <div class="hero-event__actions" id="hero-event-actions">${actionsHtml}</div>
                    </div>
                </div>
            </div>
        </section>

        <!-- Filter`;

    html = html.replace(heroSectionRegex, preRenderedHero);

    // Write back
    fs.writeFileSync(indexPath, html, 'utf8');
    console.log(`  ‚úì Hero pre-rendered: "${heroEvent.name}"`);
    console.log(`  ‚úì Preload added: ${imageAttrs.src}\n`);
}

function createGoogleCalendarLink(event) {
    const startDate = new Date(`${event.date}T${event.time}`);
    const endDate = new Date(startDate.getTime() + 2 * 60 * 60 * 1000);
    const encodedName = encodeURIComponent(event.name);
    const encodedDescription = encodeURIComponent(stripHtml(event.description || ''));
    const encodedLocation = encodeURIComponent(event.locationForCalendar || event.location);
    return `https://www.google.com/calendar/render?action=TEMPLATE&text=${encodedName}&dates=${startDate.toISOString().replace(/-|:|\.\d\d\d/g, '')}/${endDate.toISOString().replace(/-|:|\.\d\d\d/g, '')}&details=${encodedDescription}&location=${encodedLocation}`;
}

/**
 * Generate event page HTML
 */
function generateEventPage(event) {
    const eventUrl = `${SITE_URL}/events/${event.id}/`;
    const imageUrl = event.image ? `${SITE_URL}/${event.image}` : `${SITE_URL}/img/og-image.webp`;
    const categoryLabel = categoryLabels[event.category] || '–ü–æ–¥—ñ—è';
    const seoDescription = event.seo?.description || stripHtml(event.description || '');
    const description = stripHtml(event.description || '');
    const geoRegion = event.geo?.region || 'DE-NW';
    const geoPlacename = event.geo?.placename || 'K√∂ln';
    const startDateTime = formatDateISO(event.date, event.time);
    const endDateTime = formatDateISO(event.date,
        `${(parseInt(event.time.split(':')[0]) + 2).toString().padStart(2, '0')}:${event.time.split(':')[1]}`);

    // Get responsive image attributes
    const imageAttrs = getEventImageAttributes(event.image);
    const srcsetAttr = imageAttrs.srcset ? ` srcset="${imageAttrs.srcset}"` : '';

    // Logo responsive attributes
    const logoAttrs = getEventImageAttributes('img/logo.webp');
    const logoSrcset = logoAttrs.srcset ? ` srcset="${logoAttrs.srcset}"` : '';

    return `<!DOCTYPE html>
<html lang="uk">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>${event.name} | –£ –°—Ç–µ–Ω–¥–∞–ø</title>
    <meta name="description" content="${seoDescription}">
    <meta name="robots" content="index, follow">
    <link rel="canonical" href="${eventUrl}">
    <meta property="og:type" content="event">
    <meta property="og:url" content="${eventUrl}">
    <meta property="og:title" content="${event.name}">
    <meta property="og:description" content="${seoDescription}">
    <meta property="og:image" content="${imageUrl}">
    <meta property="og:site_name" content="–£ –°—Ç–µ–Ω–¥–∞–ø">
    <meta property="og:locale" content="uk_UA">
    <meta property="event:start_time" content="${startDateTime}">
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="${event.name}">
    <meta name="twitter:description" content="${seoDescription}">
    <meta name="twitter:image" content="${imageUrl}">
    <meta name="geo.region" content="${geoRegion}">
    <meta name="geo.placename" content="${geoPlacename}">
    <link rel="icon" type="image/png" sizes="48x48" href="/img/favicon-48x48.png">
    <link rel="icon" type="image/png" sizes="96x96" href="/img/favicon-96x96.png">
    <link rel="icon" type="image/png" sizes="192x192" href="/img/favicon-192x192.png">
    <link rel="apple-touch-icon" sizes="180x180" href="/img/apple-touch-icon.png">
    <link rel="shortcut icon" href="/favicon.ico">
    <link rel="stylesheet" href="/css/style.css">
    <style>
        .event-page { padding: 2rem 0; }
        .event-page__header { margin-bottom: 2rem; }
        .event-page__category { display: inline-block; padding: 0.25rem 0.75rem; background: var(--color-accent); color: var(--color-primary); border-radius: var(--radius-sm); font-size: 0.85rem; font-weight: 600; margin-bottom: 0.5rem; }
        .event-page__title { font-size: 2rem; font-weight: 700; color: var(--color-primary); margin-bottom: 1rem; }
        .event-page__meta { display: flex; flex-wrap: wrap; gap: 1.5rem; margin-bottom: 2rem; font-size: 1.1rem; }
        .event-page__meta-item { display: flex; align-items: center; gap: 0.5rem; }
        .event-page__image { width: 100%; max-width: 600px; border-radius: var(--radius-lg); margin-bottom: 2rem; cursor: pointer; }
        .event-page__description { font-size: 1.1rem; line-height: 1.8; white-space: pre-line; margin-bottom: 2rem; }
        .event-page__actions { display: flex; flex-wrap: wrap; gap: 1rem; margin-bottom: 3rem; }
        .event-page__back { margin-top: 2rem; }
        .lightbox { display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.9); z-index: 9999; cursor: pointer; justify-content: center; align-items: center; }
        .lightbox.active { display: flex; }
        .lightbox img { max-width: 90%; max-height: 90%; object-fit: contain; }
        .lightbox__close { position: absolute; top: 20px; right: 30px; color: white; font-size: 2rem; cursor: pointer; }
        @media (min-width: 768px) { .event-page__title { font-size: 2.5rem; } }
    </style>
    <script type="application/ld+json">
    {
        "@context": "https://schema.org",
        "@type": "Event",
        "name": "${event.name.replace(/"/g, '\\"')}",
        "description": "${description.replace(/"/g, '\\"')}",
        "startDate": "${startDateTime}",
        "endDate": "${endDateTime}",
        "eventStatus": "https://schema.org/EventScheduled",
        "eventAttendanceMode": "https://schema.org/OfflineEventAttendanceMode",
        "location": {
            "@type": "Place",
            "name": "${(event.geo?.name || event.location || '').replace(/"/g, '\\"')}",
            "address": {
                "@type": "PostalAddress",
                "streetAddress": "${(event.geo?.streetAddress || event.locationForCalendar || event.location || '').replace(/"/g, '\\"')}",
                "addressLocality": "${event.geo?.addressLocality || geoPlacename}",
                "postalCode": "${event.geo?.postalCode || ''}",
                "addressCountry": "${event.geo?.addressCountry || 'DE'}"
            }
        },
        "organizer": { "@type": "Organization", "name": "–£ –°—Ç–µ–Ω–¥–∞–ø", "url": "${SITE_URL}" },
        "image": "${imageUrl}"${event.performer ? `, "performer": ${JSON.stringify(event.performer)}` : ''}${event.offers ? `, "offers": ${JSON.stringify(event.offers)}` : (event.ticketLink ? `, "offers": { "@type": "Offer", "url": "${event.ticketLink}", "availability": "https://schema.org/InStock" }` : '')}
    }
    </script>
</head>
<body>
    <header>
        <nav class="navbar">
            <div class="container">
                <a class="navbar-brand" href="/"><img src="${logoAttrs.src}"${logoSrcset} alt="–£ –°—Ç–µ–Ω–¥–∞–ø" width="120" height="50"><span class="brand-tagline">—É–∫—Ä–∞—ó–Ω—Å—å–∫–∏–π —Å—Ç–µ–Ω–¥–∞–ø —É –ö–µ–ª—å–Ω—ñ</span></a>
                <button class="navbar-toggler" type="button" aria-label="Toggle navigation" onclick="toggleMenu()"><span></span><span></span><span></span></button>
                <div class="navbar-collapse" id="navbarNav">
                    <ul class="navbar-nav">
                        <li class="nav-item"><a class="nav-link" href="/">–ì–æ–ª–æ–≤–Ω–∞</a></li>
                        <li class="nav-item"><a class="nav-link active" href="/all-events.html">–í—Å—ñ –ø–æ–¥—ñ—ó</a></li>
                        <li class="nav-item"><a class="nav-link" href="/#about-us">–ü—Ä–æ –Ω–∞—Å</a></li>
                        <li class="nav-item"><a class="nav-link" href="/other-clubs.html">–Ü–Ω—à—ñ –∫–ª—É–±–∏</a></li>
                    </ul>
                </div>
            </div>
        </nav>
    </header>
    <article class="event-page">
        <div class="container">
            <div class="event-page__header">
                <span class="event-page__category">${categoryLabel}</span>
                <h1 class="event-page__title">${event.name}</h1>
                <div class="event-page__meta">
                    <div class="event-page__meta-item"><strong>üìÖ</strong> ${formatDate(event.date)}</div>
                    <div class="event-page__meta-item"><strong>üïê</strong> ${event.time}</div>
                    <div class="event-page__meta-item"><strong>üìç</strong> ${event.linkToMaps ? `<a href="${event.linkToMaps}" target="_blank" rel="noopener">${event.location}</a>` : event.location}</div>
                </div>
            </div>
            ${event.image ? `<img src="${imageAttrs.src}"${srcsetAttr} alt="${event.name}" class="event-page__image" onclick="openLightbox(this.src)">` : ''}
            <div class="event-page__description">${event.description || ''}</div>
            <div class="event-page__actions">
                ${event.ticketLink ? `<a href="${event.ticketLink}" target="_blank" class="btn btn-primary btn-lg">–ö—É–ø–∏—Ç–∏ –∫–≤–∏—Ç–∫–∏</a>` : ''}
                <a href="${createGoogleCalendarLink(event)}" target="_blank" class="btn btn-outline-secondary">Google Calendar</a>
                <button onclick="generateICS()" class="btn btn-outline-secondary">Apple Calendar</button>
            </div>
            <a href="/" class="event-page__back">‚Üê –ù–∞–∑–∞–¥ –¥–æ –≤—Å—ñ—Ö –ø–æ–¥—ñ–π</a>
        </div>
    </article>
    <div class="lightbox" id="lightbox" onclick="closeLightbox()"><span class="lightbox__close">√ó</span><img src="" alt="" id="lightbox-img"></div>
    <footer>
        <div class="container">
            <div class="footer-content">
                <div class="footer-info"><p class="footer-copyright">¬© ${new Date().getFullYear()} –£ –°—Ç–µ–Ω–¥–∞–ø. –£—Å—ñ –ø—Ä–∞–≤–∞ –∑–∞—Ö–∏—â–µ–Ω—ñ.</p><p class="footer-location">K√∂ln, Deutschland</p></div>
                <div class="footer-social">
                    <a href="https://www.instagram.com/u_standup_cologne/" target="_blank" rel="noopener"><img src="/img/instagram-icon.svg" alt="Instagram" width="32" height="32"></a>
                    <a href="https://chat.whatsapp.com/BXBNeksXPrJ29btgeo9BZZ" target="_blank" rel="noopener"><img src="/img/whatsapp-icon.svg" alt="WhatsApp" width="32" height="32"></a>
                </div>
            </div>
        </div>
    </footer>
    <script src="/ics-browserified.js"></script>
    <script>
        function toggleMenu() { const nav = document.getElementById('navbarNav'); if (nav) nav.classList.toggle('show'); }
        function openLightbox(src) { document.getElementById('lightbox-img').src = src; document.getElementById('lightbox').classList.add('active'); document.body.style.overflow = 'hidden'; }
        function closeLightbox() { document.getElementById('lightbox').classList.remove('active'); document.body.style.overflow = ''; }
        document.addEventListener('keydown', (e) => { if (e.key === 'Escape') closeLightbox(); });
        function generateICS() {
            const event = ${JSON.stringify({ id: event.id, name: event.name, date: event.date, time: event.time, description: stripHtml(event.description || ''), location: event.locationForCalendar || event.location, linkToMaps: event.linkToMaps })};
            const startDate = new Date(event.date + 'T' + event.time);
            window.ics.createEvent({ start: [startDate.getFullYear(), startDate.getMonth() + 1, startDate.getDate(), startDate.getHours(), startDate.getMinutes()], duration: { hours: 2 }, title: event.name, description: event.description, location: event.location, url: event.linkToMaps, status: 'CONFIRMED', busyStatus: 'BUSY', productId: 'u-standup/ics', alarms: [{ action: 'display', trigger: { hours: 2, before: true } }] }, (error, value) => {
                if (error) { console.error(error); return; }
                const blob = new Blob([value], { type: 'text/calendar;charset=utf-8' });
                const link = document.createElement('a'); link.href = window.URL.createObjectURL(blob); link.download = event.name + '.ics'; link.click();
            });
        }
    </script>
    <script defer src="https://static.cloudflareinsights.com/beacon.min.js" data-cf-beacon='{"token": "e9e3d01d906d4f06946bb1f72ba15410"}'></script>
    <script src="/js/analytics.js"></script>
</body>
</html>`;
}

/**
 * Build event detail pages
 */
function buildEventPages(events) {
    console.log('Building event pages...');

    const eventsDir = path.join(DIST_DIR, 'events');
    fs.mkdirSync(eventsDir, { recursive: true });

    for (const event of events) {
        const eventDir = path.join(eventsDir, event.id);
        fs.mkdirSync(eventDir, { recursive: true });

        const html = generateEventPage(event);
        fs.writeFileSync(path.join(eventDir, 'index.html'), html, 'utf8');
        console.log(`  ‚úì events/${event.id}/`);
    }

    console.log(`\nGenerated ${events.length} event pages\n`);
}

/**
 * Generate sitemap.xml
 */
function generateSitemap(events) {
    console.log('Generating sitemap.xml...');

    const today = new Date().toISOString().split('T')[0];
    const now = new Date();

    const upcomingEvents = events.filter(e => new Date(`${e.date}T${e.time}`) >= now);
    const pastEvents = events.filter(e => new Date(`${e.date}T${e.time}`) < now);

    let sitemap = `<?xml version="1.0" encoding="UTF-8"?>
<urlset xmlns="http://www.sitemaps.org/schemas/sitemap/0.9">
    <url><loc>${SITE_URL}/</loc><lastmod>${today}</lastmod><changefreq>weekly</changefreq><priority>1.0</priority></url>
    <url><loc>${SITE_URL}/all-events.html</loc><lastmod>${today}</lastmod><changefreq>weekly</changefreq><priority>0.8</priority></url>
    <url><loc>${SITE_URL}/other-clubs.html</loc><lastmod>${today}</lastmod><changefreq>monthly</changefreq><priority>0.6</priority></url>
`;

    for (const event of upcomingEvents) {
        sitemap += `    <url><loc>${SITE_URL}/events/${event.id}/</loc><lastmod>${today}</lastmod><changefreq>weekly</changefreq><priority>0.8</priority></url>\n`;
    }

    for (const event of pastEvents) {
        sitemap += `    <url><loc>${SITE_URL}/events/${event.id}/</loc><lastmod>${today}</lastmod><changefreq>yearly</changefreq><priority>0.4</priority></url>\n`;
    }

    sitemap += `    <url><loc>${SITE_URL}/data/events.json</loc><lastmod>${today}</lastmod><changefreq>weekly</changefreq><priority>0.5</priority></url>
</urlset>`;

    fs.writeFileSync(path.join(DIST_DIR, 'sitemap.xml'), sitemap, 'utf8');
    console.log('‚úì sitemap.xml');

    // Generate sitemap.txt (plain text format - one URL per line)
    const allUrls = [
        `${SITE_URL}/`,
        `${SITE_URL}/all-events.html`,
        `${SITE_URL}/other-clubs.html`,
        ...upcomingEvents.map(e => `${SITE_URL}/events/${e.id}/`),
        ...pastEvents.map(e => `${SITE_URL}/events/${e.id}/`),
        `${SITE_URL}/data/events.json`
    ];
    fs.writeFileSync(path.join(DIST_DIR, 'sitemap.txt'), allUrls.join('\n'), 'utf8');
    console.log('‚úì sitemap.txt\n');
}

/**
 * Main build function
 */
async function build() {
    console.log('=== Building dist/ for deployment ===\n');

    // Step 1: Parse HTML for image dimensions BEFORE cleaning dist
    await parseHtmlForImageDimensions();

    // Step 2: Clean and prepare dist
    cleanDist();

    // Step 3: Generate responsive images
    await generateResponsiveImages();

    // Step 4: Copy static files (with HTML transformation)
    copyStaticFiles();

    // Step 5: Pre-render header in all pages
    preRenderHeader();

    // Step 6: Build events and pages
    const events = buildEvents();
    preRenderHeroSection(events);
    buildEventPages(events);
    generateSitemap(events);

    console.log('=== Build complete! ===');
    console.log(`Output: ${DIST_DIR}`);
}

build().catch(console.error);
